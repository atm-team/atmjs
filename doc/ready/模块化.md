# 模块化
>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。
>
>希望通过该节，弄清楚javascript模块化与前端模块化的区别

## javascript模块化
本节主要通过cmd规范的子集用法简单讲解下javascript的模块化的实现原理及用途

#### javascript模块化规范分类
* [commonJs规范](http://wiki.commonjs.org/wiki/Modules/1.1)
* [amd规范](https://github.com/amdjs/amdjs-api/wiki/AMD)
* [cmd规范](https://github.com/cmdjs/specification/blob/master/draft/module.md)

###主要说下javascript的cmd规范
#### cmd规范与seajs的关系
cmd规范是javascript模块化标准,seajs是对该标准的实现，是模块加载器（或模块解析器）

#### javascript模块化的必要元素
* 模块定义 ```define(id, deps, factory)```
* 模块标识 ```id```
* 模块引用  ```require(id)```
* 模块的启动 ```seajs.use(id[, callback])```
* 模块接口 ```module.exports | exports```

> 我们把模块启动用到的id称之为 入口id

#### cmd规范的实现原理

> seajs是对cmd规范的全面实现,因此大家在看其逻辑的时候会有很多干扰，下面的代码是我对cmd规范的一个简易实现,可能对理解cmd规范的工作原理有一定的帮助。


```javascript
// analyze.js
var define;
var analyze = {};
(function () {
    var Caches = {};
    define = function (id, deps, factory) {
        var module = Caches[id] = {
            exports: {}
        };
        factory(require, module.exports, module);

    };

    function require(id) {
        return Caches[id].exports;
    }
    analyze.use = function(id, factory) {
        factory(Caches[id].exports);
    }
})();
```

```javascript
// util.js
define('./util.js', [], function (require, exports, module) {
  module.exports = {
    log: function (str) {
      console.log(str);
    }
  }
});
```
```javascript
// dialog.js
define('./dialog.js', ['./util.js'], function (require, exports, module) {
  var util = require('./util.js');
  module.exports = {
    show: function () {
      // do something
      util.log('dialog is opened');
      // do something else
    }
  }
});
```

```javascript
// demo.js
define('./demo.js', ['./util.js', './dialog.js'], function (require, exports, module) {
  var dialog = require('./dialog.js');
  module.exports = {
    init: function () {
      // do something
      dialog.show();
      // do something else
    }
  }
});
```

```html
<html>
<head>
    <meta charset="UTF-8">
    <title>demo.html</title>
</head>
<body>

<script src="./analyze.js"></script>
<script src="./dialog.js"></script>
<script src="./demo.js"></script>
<script>
    analyze.use('./demo.js', function (demo) {
        demo.init();
    });
</script>
</body>
</html>
```
看完上述代码,相信大家对cmd的工作原理基本都可以明白，那么seajs其实实现了模块文件加载的功能，因此如果上面用的是seajs作为解析器,则html代码如下：
```html
<html>
<head>
    <meta charset="UTF-8">
    <title>demo.html -- seajs版</title>
</head>
<body>

<script src="./seajs.js"></script>
<script>
    seajs.use('./demo.js', function (demo) {
        demo.init();
    });
</script>
</body>
</html>
```

#### javascript模块化给前端开发带来的好处

> 供参考文章
> 
[Why SeaJS](http://chaoskeh.com/blog/why-seajs.html)
>
>[前端模块化开发的价值](https://github.com/seajs/seajs/issues/547)（作者这里的前端模块化其实是javascript模块化）

* 避免冲突

> javascript模块化改变了javascript语言先定义后使用的特性，进而把命名权移交到引用层

```javascript
// 传统编程，我们需要先定义再使用
var util = {
  // other method or attributes
  log: function (str) {
    console.log(str);
  }
}
// 这样在引用层dialog.js中只能用变量名util来引用
```
> 只通过移交命名权并不足以避免命名冲突,因为标志名也存在同名的可能性

```javascript
// eg,项目中一直用的是小张写的util模块
define('util', [], function () {
  // some code
  method1: function () {}
});

// 有一天发现另一开源的util
define('util', [], function () {
    // some code
    method2: function () {}
});

// require('util')这时就存在不确定性

// 因为javascript模块最终的落脚点是文件
// 同时每个文件的路径是唯一的,不会冲突的
// 因此我们把模块标识与文件路径形成一一映射即可避免冲突
```
>javascript模块化最终是通过模块标志id与文件路径形成映射来避免冲突的

* 文件依赖

> 以上两篇文章都说解决了文件的依赖的问题,但其实只是解决了对javascript文件的依赖的问题,对于css文件的依赖并不适用


#### javascript模块化的狭隘性
* 性能问题

>有些加载器通过javascript运行时来支持“匿名闭包”、“依赖分析”和“模块文件加载”等功能。

* 延迟问题

> 1.只有当加载器准备就绪之后才开始对依赖的模块文件进行加载

> 2.有些加载器是惰性加载,只有在引用时才会去加载依赖的模块文件

* 不利于打包部署

>javascript模块化方案更多的考虑是如何将代码进行拆分，但是当我们部署上线的时候需要将静态资源进行合并（打包），这个时候会发现困难重重，尤其是当模块使用的是“匿名定义”时，开发者不仅仅需要在本地开发关注模块化的拆分，在调用的时候还需要关注在一个请求里面加载哪些模块比较合适，模块化的初衷是为了提高开发效率、降低维护成本，但我们发现这样的模块化方案实际上并没有降低维护成本，某种程度上来说使得整个项目更加复杂了。

* 文件依赖主要解决了对javascript文件的依赖,对css文件的依赖不适用


## 前端模块化
> 前端开发相对其他语言来说比较特殊，因为我们实现一个页面功能总是需要 JavaScript、CSS 和 Template 三种语言相互组织才行，如果一个功能仅仅只有 JavaScript 实现了模块化，CSS 和 Template 还是处于原始状态，那我们调用这个功能的时候并不能完全通过模块化的方式，那么这样的模块化方案并不是完整的，所以我们真正需要的是一种可以将 JavaScript、CSS 和 Template 同时都考虑进去的模块化方案，而非仅仅 JavaScript 模块化方案。(摘自http://fex.baidu.com/blog/2014/03/fis-module/)

> 由此可见，对于一个前端开发者来说，代码开发层需要javascript模块化,在前端架构方面需要的是前端模块化
